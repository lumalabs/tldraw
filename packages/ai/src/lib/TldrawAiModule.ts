import { Box, BoxModel, Editor, FileHelpers, structuredClone } from 'tldraw'
import { TldrawAiTransforms } from './TldrawAiTransform'
import { TLAiContent, TLAiMessage, TLAiPrompt, TLAiStreamingChange } from './types'
import { TldrawAiApplyFn } from './useTldrawAi'
import { asMessage } from './utils'

/** @public */
export interface TldrawAiModuleOptions<Prompt, Change> {
	transforms:
		| TldrawAiTransforms<Prompt, Change>
		| ((transforms: TldrawAiTransforms) => TldrawAiTransforms<Prompt, Change>)
}

export interface TldrawAiGenerateOptions {
	/** The user's written prompt or an array of messages */
	message: string | TLAiMessage[]
	/** The content pulled from the editor */
	canvasContent?: TLAiContent
	/** The bounds of the context in the editor */
	contextBounds?: BoxModel
	/** The bounds of the prompt in the editor */
	promptBounds?: BoxModel
	/** Any additional information. Must be JSON serializable! */
	meta?: any
}
/**
 * The AI manager for tldraw. This class is used to produce prompts for the AI
 * using data from the editor, and to update the editor based on the
 * changes generated by the AI.
 *
 * @public
 */
export class TldrawAiModule<Prompt = TLAiPrompt, Change = TLAiStreamingChange> {
	constructor(
		public readonly editor: Editor,
		public readonly opts = {} as TldrawAiModuleOptions<Prompt, Change>
	) {}

	dispose() {}

	/**
	 * Creates and prepare a prompt, returning the prompt
	 * and a function to handle changes.
	 *
	 * @param options - Options for the prompt
	 */
	async generate(options: TldrawAiGenerateOptions) {
		const { transforms: transformsFn = TldrawAiTransforms.empty } = this.opts
		const transforms = (
			typeof transformsFn === 'function' ? transformsFn(TldrawAiTransforms.empty) : transformsFn
		).transforms

		let _prompt: any = await this.getPrompt(options)
		const changeTransforms: ((change: any) => any)[] = []

		for (const transform of transforms) {
			const result = transform(this.editor, _prompt)
			if (result.prompt) {
				_prompt = result.prompt
			}
			if (result.handleChange) {
				changeTransforms.push(result.handleChange)
			}
		}

		const prompt: Prompt = _prompt

		changeTransforms.reverse()

		const handleChange = (change: Change, apply: TldrawAiApplyFn) => {
			let _change: any = change
			for (const changeTransform of changeTransforms) {
				const result = changeTransform(change)
				if (result) {
					_change = result
				} else {
					return
				}
			}
			const finalChange: TLAiStreamingChange = _change
			apply({ change: finalChange, editor: this.editor })
		}

		return {
			prompt,
			handleChange,
		}
	}

	/**
	 * Create the prompt to be sent to the AI.
	 *
	 * @param options - Options to generate the input
	 */
	async getPrompt(options: TldrawAiGenerateOptions): Promise<TLAiPrompt> {
		const { editor } = this
		const {
			message,
			contextBounds = editor.getViewportPageBounds(),
			promptBounds = editor.getViewportPageBounds(),
			canvasContent = this.getContent(promptBounds),
			meta,
		} = options

		// Get image from the content
		const image = await this.getImage(canvasContent)

		return {
			message: asMessage(message),
			canvasContent,
			contextBounds: roundBox(contextBounds),
			promptBounds: roundBox(promptBounds),
			image,
			meta,
		}
	}

	/**
	 * Get the content from the current page.
	 *
	 * @param bounds - The bounds to get the content for
	 */
	private getContent(bounds: BoxModel): TLAiContent {
		const { editor } = this

		const boundsBox = Box.From(bounds)

		// Get the page content (same as what we put on the clipboard when a user copies) for the shapes
		// that are included (contained or colliding with) the provided bounds

		let content: TLAiContent | undefined = {
			bindings: [],
			shapes: [],
			assets: [],
			...editor.getContentFromCurrentPage(
				editor
					.getCurrentPageShapesSorted()
					.filter((s) => boundsBox.includes(editor.getShapeMaskedPageBounds(s)!))
			),
		}

		// If we don't have content, it's either an empty page or an empty section of the page.
		// This is an acceptable case; but let's send along an empty content instead of undefined.
		if (content) {
			// the content is a TLContent, but we want to omit the schema for TLAiContent
			content.shapes = structuredClone(content.shapes)
			content.bindings = structuredClone(content.bindings)
			delete (content as any).schema
			delete (content as any).rootShapeIds
		} else {
			content = {
				shapes: [],
				bindings: [],
				assets: [],
			}
		}

		return content
	}

	/**
	 * Get a screenshot (data URL) of the prompt's content
	 *
	 * @param content - The content to get the image from
	 */
	private async getImage(content: TLAiContent) {
		if (!content.shapes.length) return undefined

		const result = await this.editor.toImage(content.shapes, {
			format: 'jpeg',
			background: false,
			darkMode: false,
			padding: 0, // will the context bounds take into account the padding?
		})

		return await FileHelpers.blobToDataUrl(result.blob)
	}
}

function roundBox(box: BoxModel): BoxModel {
	return {
		x: Math.round(box.x),
		y: Math.round(box.y),
		w: Math.round(box.w),
		h: Math.round(box.h),
	}
}
