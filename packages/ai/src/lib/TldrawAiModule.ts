import { Box, Editor, FileHelpers, structuredClone } from 'tldraw'
import { TldrawAiTransformConstructor } from './TldrawAiTransform'
import { TLAiContent, TLAiPrompt, TLAiStreamingChange } from './types'
import { TldrawAiApplyFn, TldrawAiPromptOptions } from './useTldrawAi'

/** @public */
export interface TldrawAiModuleOptions {
	editor: Editor
	transforms?: TldrawAiTransformConstructor[]
}

/**
 * The AI manager for tldraw. This class is used to produce prompts for the AI
 * using data from the editor, and to update the editor based on the
 * changes generated by the AI.
 *
 * @public
 */
export class TldrawAiModule {
	constructor(public readonly opts = {} as TldrawAiModuleOptions) {}

	dispose() {}

	/**
	 * Creates and prepare a prompt, returning the prompt
	 * and a function to handle changes.
	 *
	 * @param options - The user's message or a configuration for the prompt
	 */
	async generate(options: TldrawAiPromptOptions) {
		const { transforms: _transformCtors = [] } = this.opts
		const transforms = _transformCtors.map((ctor) => new ctor(this.opts.editor))

		let prompt = await this.getPrompt(options)

		for (const transform of transforms) {
			if (transform.transformPrompt) {
				prompt = transform.transformPrompt(prompt)
			}
		}

		transforms.reverse()

		const handleChange = (change: TLAiStreamingChange, apply: TldrawAiApplyFn) => {
			for (const transform of transforms) {
				if (transform.transformChange) {
					change = transform.transformChange(change)
				}
			}
			apply({ change, editor: this.opts.editor })
		}

		return {
			prompt,
			handleChange,
		}
	}

	/**
	 * Create a full prompt to be sent to the AI.
	 *
	 * @param options - The options to generate the prompt
	 */
	async getPrompt(options: TldrawAiPromptOptions): Promise<TLAiPrompt> {
		const { editor } = this.opts

		const _options = typeof options === 'string' ? { message: options } : options

		const contextBounds = _options.contextBounds ?? editor.getViewportPageBounds()
		const promptBounds = _options.promptBounds ?? editor.getViewportPageBounds()
		const canvasContent = _options.canvasContent ?? this.getContent(contextBounds)
		const image = _options.image ?? (await this.getImage(canvasContent))

		return {
			message: _options.message ?? '',
			canvasContent,
			contextBounds: roundBox(contextBounds),
			promptBounds: roundBox(promptBounds),
			image,
			meta: _options.meta,
		}
	}

	/**
	 * Get the content from the current page.
	 *
	 * @param bounds - The bounds to get the content for. If not provided, includes the entire page.
	 */
	private getContent(bounds?: Box): TLAiContent {
		const { editor } = this.opts

		let shapesToInclude

		if (!bounds) {
			// No bounds provided, include all shapes on the current page
			shapesToInclude = editor.getCurrentPageShapesSorted()
		} else {
			// Only include shapes within or colliding with the provided bounds
			shapesToInclude = editor
				.getCurrentPageShapesSorted()
				.filter((s) => bounds.includes(editor.getShapeMaskedPageBounds(s)!))
		}

		let content: TLAiContent | undefined = {
			bindings: [],
			shapes: [],
			assets: [],
			...editor.getContentFromCurrentPage(shapesToInclude),
		}

		// If we don't have content, it's either an empty page or an empty section of the page.
		// This is an acceptable case; but let's send along an empty content instead of undefined.
		if (content) {
			// the content is a TLContent, but we want to omit the schema for TLAiContent
			content.shapes = structuredClone(content.shapes)
			content.bindings = structuredClone(content.bindings)
			delete (content as any).schema
			delete (content as any).rootShapeIds
		} else {
			content = {
				shapes: [],
				bindings: [],
				assets: [],
			}
		}

		return content
	}

	/**
	 * Get a screenshot (data URL) of the prompt's content
	 *
	 * @param content - The content to get the image from
	 */
	private async getImage(content: TLAiContent) {
		if (!content.shapes.length) return undefined

		const result = await this.opts.editor.toImage(content.shapes, {
			format: 'jpeg',
			background: false,
			darkMode: false,
			padding: 10, // will the context bounds take into account the padding?
		})

		return await FileHelpers.blobToDataUrl(result.blob)
	}
}

function roundBox(box: Box) {
	const b = box.clone()
	b.x = Math.round(b.x)
	b.y = Math.round(b.y)
	b.width = Math.round(b.width)
	b.height = Math.round(b.height)
	return b
}
